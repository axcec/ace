<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ace</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Courier New', monospace;
      max-width: 600px;
      margin: 0 auto;
      padding: 40px 20px;
      line-height: 1.8;
      transition: background-color 0.3s, color 0.3s;
    }
    body.light {
      background-color: #ffffff;
      color: #1a1a1a;
    }
    body.dark {
      background-color: #0a0a0a;
      color: #e8e8e8;
    }
    header {
      margin-bottom: 60px;
    }
    nav {
      display: flex;
      gap: 20px;
      font-size: 16px;
    }
    nav a {
      color: inherit;
      text-decoration: none;
      opacity: 0.75;
      transition: opacity 0.3s ease;
    }
    nav a:hover {
      opacity: 1;
    }
    .theme-toggle {
      position: fixed;
      top: 40px;
      right: 40px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      display: flex;
      opacity: 0.7;
      transition: all 0.3s ease;
    }
    .theme-toggle:hover {
      opacity: 1;
      transform: rotate(180deg);
    }
    .theme-toggle:focus {
      outline: 2px solid currentColor;
      outline-offset: 4px;
    }
    .theme-icon {
      width: 18px;
      height: 18px;
    }
    .light .theme-icon {
      fill: #000;
    }
    .dark .theme-icon {
      fill: #fff;
    }
    main p {
      opacity: 0;
      animation: fadeIn 1s ease forwards;
      animation-delay: 0.3s;
      font-size: 16px;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    nav a {
      position: relative;
    }
    nav a::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 0;
      height: 1px;
      background: currentColor;
      transition: width 0.3s ease;
    }
    nav a:hover::after {
      width: 100%;
    }
    main {
      font-size: 14px;
    }
    .section {
      display: none;
      opacity: 0;
      animation: fadeIn 1s ease forwards;
    }
    .section.active {
      display: block;
    }
    .section h2 {
      font-size: 16px;
      margin-bottom: 30px;
      font-weight: normal;
    }
    .blog-item {
      text-decoration: none;
      color: inherit;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      opacity: 0.75;
      transition: opacity 0.3s ease;
      margin-bottom: 12px;
    }
    .blog-item:hover {
      opacity: 1;
    }
    .blog-date {
      font-size: 14px;
      opacity: 0.6;
    }
    .collection-intro {
      margin-bottom: 40px;
      line-height: 1.8;
    }
    .collection-section {
      margin-bottom: 50px;
    }
    .collection-section h3 {
      font-size: 14px;
      font-weight: normal;
      margin-bottom: 20px;
      opacity: 0.8;
    }
    .collection-item {
      margin-bottom: 8px;
      line-height: 1.6;
    }
    .collection-item.highlight {
      color: #ff4444;
    }
    .social-links {
      display: flex;
      gap: 16px;
      margin-top: 40px;
      opacity: 0;
      animation: fadeIn 1s ease forwards;
      animation-delay: 0.6s;
    }
    .social-links a {
      opacity: 0.7;
      transition: opacity 0.3s ease, transform 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .social-links a:hover {
      opacity: 1;
      transform: translateY(-2px);
    }
    .social-icon {
      width: 20px;
      height: 20px;
    }
    .light .social-icon {
      fill: #000;
    }
    .dark .social-icon {
      fill: #fff;
    }
  </style>
</head>
<body class="dark">
  <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
    <svg class="theme-icon" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="5"/>
      <line x1="12" y1="1" x2="12" y2="3" stroke="currentColor" stroke-width="2"/>
      <line x1="12" y1="21" x2="12" y2="23" stroke="currentColor" stroke-width="2"/>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="currentColor" stroke-width="2"/>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="currentColor" stroke-width="2"/>
      <line x1="1" y1="12" x2="3" y2="12" stroke="currentColor" stroke-width="2"/>
      <line x1="21" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2"/>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="currentColor" stroke-width="2"/>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="currentColor" stroke-width="2"/>
    </svg>
  </button>

  <header>
    <nav>
      <a href="#about" onclick="showSection('about')">about</a>
      <a href="#blogs" onclick="showSection('blogs')">blogs</a>
      <a href="#collection" onclick="showSection('collection')">collection</a>
    </nav>
  </header>
  
  <main id="about" class="section active">
    <p>hi i'm <strong>prasad firame</strong>.</p>
    <p>i'm just a guy who builds stuff.</p>
    <p>been here since <span id="age">22.348946165</span> years.</p>
    <br>
   
    <p>i love backend engineering, systems, and architectures.</p>
    <p>love tinkering around with llms and coming ai stuff.</p>
    <p>currently learning about distributed systems and infra.</p>
    <br>
    <p>in my free time, i read and write blogs around architectures and running ai workloads on the cloud/mlops.</p>
    
    <div class="social-links">
     
      <a href="https://x.com/aceXdev" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
        <svg class="social-icon" viewBox="0 0 24 24">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
      </a>
      
      <a href="https://bsky.app" target="_blank" rel="noopener noreferrer" aria-label="Bluesky">
        <svg class="social-icon" viewBox="0 0 24 24">
          <path d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.275-.039.415-.056-.138.022-.276.04-.415.056-3.912.58-7.387 2.005-2.83 7.078 5.013 5.19 6.87-1.113 7.823-4.308.953 3.195 2.05 9.271 7.733 4.308 4.267-4.308 1.172-6.498-2.74-7.078a8.741 8.741 0 0 1-.415-.056c.14.017.279.036.415.056 2.67.297 5.568-.628 6.383-3.364.246-.828.624-5.79.624-6.478 0-.69-.139-1.861-.902-2.206-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8z"/>
        </svg>
      </a>
      
      <a href="https://www.linkedin.com/in/prasad-firame-636a9a227/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
        <svg class="social-icon" viewBox="0 0 24 24">
          <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
        </svg>
      </a>

       <a href="https://discord.gg/rS3rqwC3" target="_blank" rel="noopener noreferrer" aria-label="Discord">
        <svg class="social-icon" viewBox="0 0 24 24">
          <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
        </svg>
      </a>
      
    </div>
  </main>

  <section id="blogs" class="section">
    <div>
      <a href="#" class="blog-item" onclick="showBlogPost(event)">
        <span>Lock-Free LRU Cache</span>
        <span class="blog-date">nov 2024</span>
      </a>
    </div>
  </section>

  <section id="blog-post" class="section">
    <div style="margin-bottom: 30px;">
      <a href="#blogs" onclick="showSection('blogs')" style="opacity: 0.6; text-decoration: none; color: inherit;">← back to blogs</a>
    </div>
    <h1 style="font-size: 24px; margin-bottom: 10px; font-weight: normal;">Lock-Free LRU Cache</h1>
    <p style="opacity: 0.6; margin-bottom: 40px; font-size: 14px;">november 2024</p>
    
    <div style="line-height: 1.8; font-size: 15px;">
      <p style="margin-bottom: 20px;">caching is one of those fundamental patterns in software engineering that everyone implements at some point. the concept is simple: keep frequently accessed data close by so you don't have to fetch it from slower storage every time. but as with most things in distributed systems and concurrent programming, the devil is in the details.</p>

      <p style="margin-bottom: 20px;">the least recently used (lru) cache is a popular eviction policy. when the cache is full and you need to make room for new data, you evict the item that hasn't been accessed in the longest time. it's intuitive and works well in practice for many workloads.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">the traditional approach</h2>

      <p style="margin-bottom: 20px;">most lru cache implementations use a combination of a hash map for o(1) lookups and a doubly linked list to track access order. when you access an item, you move it to the front of the list. when you need to evict, you remove from the back.</p>

      <p style="margin-bottom: 20px;">this works great in single-threaded environments. but what happens when multiple threads are trying to read and write to the cache simultaneously? the naive approach is to wrap everything in a mutex. every operation—reads, writes, updates—requires acquiring a lock.</p>

      <p style="margin-bottom: 20px;">the problem with locks is contention. when you have high concurrency, threads spend more time waiting for locks than doing useful work. cache hits become cache misses in terms of performance. you've essentially serialized access to what should be a fast data structure.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">why go lock-free?</h2>

      <p style="margin-bottom: 20px;">lock-free data structures use atomic operations and compare-and-swap (cas) instructions instead of locks. the key insight is that you can make progress without mutual exclusion. at least one thread will always make progress, even if others are delayed or fail.</p>

      <p style="margin-bottom: 20px;">for a cache specifically, this means:</p>
      
      <p style="margin-bottom: 10px; padding-left: 20px;">• reads don't block writes</p>
      <p style="margin-bottom: 10px; padding-left: 20px;">• writes don't block reads</p>
      <p style="margin-bottom: 20px; padding-left: 20px;">• no thread holds a global lock that stops everyone else</p>

      <p style="margin-bottom: 20px;">the performance characteristics are dramatically different. instead of contention increasing linearly with thread count, you get much better scaling. it's not perfect—cas operations can fail and retry—but it's way better than blocking.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">the challenge</h2>

      <p style="margin-bottom: 20px;">implementing a lock-free lru cache is tricky. the traditional doubly-linked list approach doesn't translate well to lock-free because updating both forward and backward pointers atomically is hard. you'd need to cas multiple memory locations at once, which hardware doesn't support.</p>

      <p style="margin-bottom: 20px;">so you need to rethink the data structure. some approaches use lock-free hash tables with approximate lru tracking. you don't maintain perfect lru order—you maintain good enough order. this is actually fine for most use cases because caching is fundamentally about probabilistic optimization anyway.</p>

      <p style="margin-bottom: 20px;">another approach is to segment the cache. instead of one global lru list, you have multiple segments, each with their own lru tracking. this reduces contention because threads are less likely to compete for the same segment. it's not fully lock-free, but it's lock-reduced, which can be good enough.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">design considerations</h2>

      <p style="margin-bottom: 20px;">when building a lock-free lru cache, you need to think about several things:</p>

      <p style="margin-bottom: 20px;"><strong>memory ordering:</strong> lock-free code is sensitive to memory ordering. you need to understand acquire/release semantics and memory barriers. different architectures have different memory models. what works on x86 might not work on arm.</p>

      <p style="margin-bottom: 20px;"><strong>aba problem:</strong> this is a classic lock-free gotcha. you read a value, another thread changes it and then changes it back, and your cas succeeds even though the state changed. you need tagged pointers or hazard pointers to handle this.</p>

      <p style="margin-bottom: 20px;"><strong>reclamation:</strong> when you remove a node from the cache, you can't just free it immediately because another thread might still be reading it. you need a safe memory reclamation strategy like epoch-based reclamation or hazard pointers.</p>

      <p style="margin-bottom: 20px;"><strong>fairness:</strong> lock-free doesn't mean wait-free. some threads might keep retrying while others make progress. you need to think about starvation and fairness.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">practical implementation</h2>

      <p style="margin-bottom: 20px;">in practice, i've found that hybrid approaches work well. you can use lock-free techniques for the hot path (reads) and fall back to locks for less frequent operations (eviction, resizing).</p>

      <p style="margin-bottom: 20px;">for example, you might have a lock-free hash table for lookups, but when you need to evict items, you acquire a lock to update the lru metadata. most cache workloads are read-heavy, so this gives you lock-free performance where it matters most.</p>

      <p style="margin-bottom: 20px;">another trick is to use thread-local caches with a shared backing cache. each thread has its own small cache that requires no synchronization. only cache misses go to the shared cache. this reduces contention significantly.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">benchmarking matters</h2>

      <p style="margin-bottom: 20px;">you can't know if your lock-free cache is actually faster without benchmarking. and not just microbenchmarks—you need to test with realistic workloads that match your production patterns.</p>

      <p style="margin-bottom: 20px;">things to measure:</p>
      
      <p style="margin-bottom: 10px; padding-left: 20px;">• throughput at different thread counts</p>
      <p style="margin-bottom: 10px; padding-left: 20px;">• latency percentiles (p50, p99, p999)</p>
      <p style="margin-bottom: 10px; padding-left: 20px;">• cache hit rate</p>
      <p style="margin-bottom: 20px; padding-left: 20px;">• memory overhead</p>

      <p style="margin-bottom: 20px;">sometimes a simpler locked cache with good cache line awareness and padding will outperform a fancy lock-free implementation. the only way to know is to measure.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">existing solutions</h2>

      <p style="margin-bottom: 20px;">you don't always need to roll your own. there are good existing implementations:</p>

      <p style="margin-bottom: 20px;"><strong>caffeine (java):</strong> a high-performance caching library that uses advanced techniques like tinylfu for admission policy and w-tinylfu for eviction. it's not fully lock-free but achieves excellent concurrent performance.</p>

      <p style="margin-bottom: 20px;"><strong>folly concurrent hash map (c++):</strong> facebook's folly library has a concurrent hash map that can be combined with lru tracking. it uses fine-grained locking and lock-free techniques.</p>

      <p style="margin-bottom: 20px;"><strong>concurrent lru in rust:</strong> the rust ecosystem has several implementations that leverage rust's ownership system to provide safe concurrent access.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">when to use lock-free</h2>

      <p style="margin-bottom: 20px;">lock-free isn't always the answer. here's when it makes sense:</p>

      <p style="margin-bottom: 20px;"><strong>high contention:</strong> when you have many threads competing for cache access, lock-free can significantly reduce contention.</p>

      <p style="margin-bottom: 20px;"><strong>predictable latency:</strong> locks can cause priority inversion and unpredictable delays. lock-free gives you better tail latencies.</p>

      <p style="margin-bottom: 20px;"><strong>read-heavy workloads:</strong> if most operations are reads, lock-free reads give you massive parallelism.</p>

      <p style="margin-bottom: 20px;">when to avoid it:</p>

      <p style="margin-bottom: 20px;"><strong>complexity isn't worth it:</strong> if your cache isn't a bottleneck, the added complexity of lock-free code isn't justified.</p>

      <p style="margin-bottom: 20px;"><strong>write-heavy workloads:</strong> lots of writes mean lots of cas retries. a well-designed locked implementation might actually be faster.</p>

      <p style="margin-bottom: 20px;"><strong>simple requirements:</strong> if you just need a cache for a low-traffic service, use the standard library's map with a mutex. done.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">lessons learned</h2>

      <p style="margin-bottom: 20px;">building lock-free data structures taught me several things:</p>

      <p style="margin-bottom: 20px;">first, correctness is hard. lock-free code has subtle bugs that only show up under high concurrency or specific race conditions. you need extensive testing with thread sanitizers and stress tests.</p>

      <p style="margin-bottom: 20px;">second, performance is hardware-dependent. what's fast on your laptop might be slow on the production server with different cpu architecture and cache topology.</p>

      <p style="margin-bottom: 20px;">third, documentation matters. lock-free code is hard to understand. future you (or your teammates) will thank you for explaining the invariants and memory ordering requirements.</p>

      <p style="margin-bottom: 20px;">fourth, there's no silver bullet. sometimes the best solution is a boring mutex with careful lock granularity. premature optimization and all that.</p>

      <h2 style="font-size: 18px; margin: 40px 0 20px 0; font-weight: normal;">final thoughts</h2>

      <p style="margin-bottom: 20px;">lock-free lru caches are a fascinating intersection of systems programming, concurrent algorithms, and performance engineering. they're not always necessary, but when you need them, they can unlock significant performance gains.</p>

      <p style="margin-bottom: 20px;">the key is understanding the tradeoffs. lock-free doesn't mean faster—it means different performance characteristics. you trade algorithmic complexity for reduced contention. whether that's worth it depends on your specific use case.</p>

      <p style="margin-bottom: 20px;">if you're building a high-performance cache for a latency-sensitive system with high concurrency, investigating lock-free approaches is worth your time. start simple, measure everything, and optimize based on data.</p>

      <p style="margin-bottom: 20px;">and remember: the best cache is often no cache at all. sometimes the right answer is to make the underlying operation fast enough that you don't need caching. but when you do need a cache, and it needs to be concurrent, lock-free techniques are a powerful tool in your arsenal.</p>

      <p style="margin-bottom: 20px;">go build something fast.</p>
    </div>
  </section>

  <section id="collection" class="section">
    <div class="collection-intro">
      <p>this is a living library of quotes, anime, manga, songs, movies, and engineers i admire.</p>
      <p>i add new things over time.</p>
      <p>the pieces in <span style="color: #ff4444;">red</span> either hit me hard or are things i really want.</p>
    </div>

    <div class="collection-section">
      <h3>quotes i live by</h3>
      <div class="collection-item">"Stay hungry, stay foolish" — Steve Jobs</div>
      <div class="collection-item">"Move fast and break things" — Mark Zuckerberg</div>
      <div class="collection-item">"Make it work, make it right, make it fast" — Kent Beck</div>
      <div class="collection-item">"The best way to predict the future is to invent it" — Alan Kay</div>
      <div class="collection-item">"Talk is cheap. Show me the code" — Linus Torvalds</div>
      <div class="collection-item">"Simplicity is prerequisite for reliability" — Edsger Dijkstra</div>
      <div class="collection-item">"First, solve the problem. Then, write the code" — John Johnson</div>
    </div>

    <div class="collection-section">
      <h3>anime i love</h3>
      <div class="collection-item highlight">One Piece</div>
      <div class="collection-item">Vinland Saga</div>
    </div>

    <div class="collection-section">
      <h3>manga i read</h3>
      <div class="collection-item">Berserk</div>
      <div class="collection-item highlight">Vagabond</div>
    </div>

    <div class="collection-section">
      <h3>songs i like</h3>
      <div class="collection-item">Avicii - Wake Me Up</div>
      <div class="collection-item highlight">Illenium - Good Things Fall Apart</div>
      <div class="collection-item">The Chainsmokers - Closer</div>
    </div>

    <div class="collection-section">
      <h3>movies i love</h3>
      <div class="collection-item">The Social Network (120m)</div>
      <div class="collection-item highlight">Interstellar (169m)</div>
      <div class="collection-item">The Imitation Game (114m)</div>
    </div>

    <div class="collection-section">
      <h3>engineers i admire</h3>
      <div class="collection-item highlight">Linus Torvalds</div>
      <div class="collection-item">DHH (David Heinemeier Hansson)</div>
      <div class="collection-item">John Carmack</div>
      <div class="collection-item">Jeff Dean</div>
    </div>
  </section>

  <script>
    function showBlogPost(event) {
      event.preventDefault();
      const sections = document.querySelectorAll('.section');
      sections.forEach(section => {
        section.classList.remove('active');
      });
      document.getElementById('blog-post').classList.add('active');
    }

    function showSection(sectionId) {
      event.preventDefault();
      const sections = document.querySelectorAll('.section');
      sections.forEach(section => {
        section.classList.remove('active');
      });
      document.getElementById(sectionId).classList.add('active');
    }

    function calculateAge() {
      const birthDate = new Date('2003-03-18');
      const now = new Date();
      const ageInMs = now - birthDate;
      const ageInYears = ageInMs / (1000 * 60 * 60 * 24 * 365.25);
      document.getElementById('age').textContent = ageInYears.toFixed(9);
    }
    
    calculateAge();
    setInterval(calculateAge, 100);

    function toggleTheme() {
      const body = document.body;
      const icon = document.querySelector('.theme-icon');
      
      if (body.classList.contains('light')) {
        body.classList.remove('light');
        body.classList.add('dark');
        icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
      } else {
        body.classList.remove('dark');
        body.classList.add('light');
        icon.innerHTML = '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3" stroke="currentColor" stroke-width="2"/><line x1="12" y1="21" x2="12" y2="23" stroke="currentColor" stroke-width="2"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="currentColor" stroke-width="2"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="currentColor" stroke-width="2"/><line x1="1" y1="12" x2="3" y2="12" stroke="currentColor" stroke-width="2"/><line x1="21" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="currentColor" stroke-width="2"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="currentColor" stroke-width="2"/>';
      }
    }
  </script>
</body>
</html>
